\documentclass[12pt,a4paper]{article}

\usepackage[left=3.00cm, right=2.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{microtype}

\usepackage{indentfirst,setspace}
\setlength{\parindent}{1.3cm}
\setlength{\parskip}{0.2cm}
\singlespacing

\usepackage{amssymb,amsmath,amsfonts}

\usepackage[numbers]{natbib}
\usepackage{url}
\bibliographystyle{plainnat}

\usepackage{longtable}
\usepackage{booktabs}
\usepackage[skip=1pt,labelfont=bf]{caption}
\usepackage{float}

\usepackage{tikz}
\usepackage[portuguese, ruled]{algorithm2e}

\usepackage{array}
\newcolumntype{C}{>{\centering\arraybackslash}p{1cm}}
\renewcommand*{\arraystretch}{1.2}


\makeatletter
\newcommand{\algorithmfootnote}[2][\footnotesize]{%
	\let\old@algocf@finish\@algocf@finish% Store algorithm finish macro
	\def\@algocf@finish{\old@algocf@finish% Update finish macro to insert "footnote"
		\leavevmode\rlap{\begin{minipage}{\linewidth}
				#1#2
		\end{minipage}}%
	}%
}
\makeatother

\numberwithin{figure}{section}
\numberwithin{table}{section}


\author{Pablo Cecilio Oliveira\\
	Alexander Cristian}
\title{Algorítimos e Estrutura de Dados III\\
O Problema da Viagem do Torneio}
\date{}

\begin{document}
\maketitle

\section{Introdução}

O Problema da Viagem do Torneio Viajante (\textit{Traveling Tournament Problem}) pode ser considerado como um problema de otimização matemática que envolve a criação de uma escala de jogos viável para um torneio. Essa viabilidade pode ser definida de maneira geral por dois outros problemas. O primeiro é uma questão de viabilidade, o padrão de jogos em casa e longe deve ser suficientemente variado, de modo a evitar padrões de estadia e deslocamento excessivos. O segundo é uma questão de deslocamento, onde buscasse minimizar o custo total de deslocamento com objetivo de evitar viagens excessivas.

Neste trabalho prático é apresentado uma solução para o TTP do Campeonato Brasileiro de Futebol.

A escala de jogos do Campeonato Brasileiro de Futebol consiste em definir uma escala de jogos viável entre $n$ times divididos em $n-1$ rodadas $k$ no primeiro turno, onde cada time joga com cada um dos outros sem repetições, e sem que existam mais que três jogos consecutivos fora de casa. Para o returno na rodada $k + (n - 1)$, os jogos são espelhados do primeiro turno, porem com o mando de campo invertido.

Na solução final para o problema, o custo de deslocamento dos times na escala de jogos deve ser considerado e seu retorno minimizado.

\section{Implementação}

Para a construção de uma solução inicial, utiliza-se o método de três fases proposto por Ribeiro e Urrutia (2004a)\cite{urrutia:heuristics}, e posteriormente para o refinamento dos resultados foi adotada um método heurístico de LNS (large neighborhood search), introduzido por Shaw (1997)\cite{tp:Shaw}.

\subsection{Método de três fases para geração de uma solução inicial}

\subsubsection{Primeira fase: Método do Polígono}
\label{subsec:primeirafase}

A primeira fase da solução inicial consiste em uma fatoração que utiliza o Método do Polígono. Nesse método, sendo $n$ o número de times participantes do campeonato, forma-se um polígono com $n-1$ nós numerados e um $n$-ésimo time é atribuído a um nó fora desse polígono.

A cada rodada, os times localizados nos nós $k=2,3,...,n/2$ jogam contra os times localizados nos nós $n+1-k$, o $n$-ésimo time localizado fora do polígono joga contra o time localizado no primeiro nó do polígono. Para as $n-1$ rodadas seguintes, o polígono é movido em sentido horário para determinar os novos jogos. A Figura \ref{fig:poligono}, demonstra a fatoração para as três primeiras rodadas de um campeonato com $6$ times.

\begin{figure}[H]
	\centering
	\caption{Método do Polígono para três primeiras rodadas com n = 6}
	\label{fig:poligono}
	\vspace{0.3cm}
	\begin{tikzpicture}
		\tikzstyle{every node}=[draw, shape=circle, inner sep=4pt];
		\tikzstyle{every path}=[draw, line width=0.4mm];
		\node (F) at (0,6) {$6$};
		\node (A) at (0,4) {$1$};
		\node (B) at (2,2.25) {$2$};
		\node (C) at (1.25,0) {$3$};
		\node (D) at (-1.25,0) {$4$};
		\node (E) at (-2,2.25) {$5$};
		\draw (A)--(B)--(C)--(D)--(E)--(A);
		\draw [<->] (0,5.5) -- (0,4.5);
		\draw [<->] (-1.5,2.25) -- (1.5,2.25);
		\draw [<->] (-0.8,0.2) -- (0.8,0.2);
	\end{tikzpicture}
	\hfil
	\begin{tikzpicture}
		\tikzstyle{every node}=[draw, shape=circle, inner sep=4pt];
		\tikzstyle{every path}=[draw, line width=0.4mm];
		\node (F) at (0,6) {$6$};
		\node (A) at (0,4) {$5$};
		\node (B) at (2,2.25) {$1$};
		\node (C) at (1.25,0) {$2$};
		\node (D) at (-1.25,0) {$3$};
		\node (E) at (-2,2.25) {$4$};
		\draw (A)--(B)--(C)--(D)--(E)--(A);
		\draw [<->] (0,5.5) -- (0,4.5);
		\draw [<->] (-1.5,2.25) -- (1.5,2.25);
		\draw [<->] (-0.8,0.2) -- (0.8,0.2);
		\draw [->] (1,4.25) to[out=10,in=-270] (2.25,3.25);
	\end{tikzpicture}
	\hfil
	\begin{tikzpicture}
		\tikzstyle{every node}=[draw, shape=circle, inner sep=4pt];
		\tikzstyle{every path}=[draw, line width=0.4mm];
		\node (F) at (0,6) {$6$};
		\node (A) at (0,4) {$4$};
		\node (B) at (2,2.25) {$5$};
		\node (C) at (1.25,0) {$1$};
		\node (D) at (-1.25,0) {$2$};
		\node (E) at (-2,2.25) {$3$};
		\draw (A)--(B)--(C)--(D)--(E)--(A);
		\draw [<->] (0,5.5) -- (0,4.5);
		\draw [<->] (-1.5,2.25) -- (1.5,2.25);
		\draw [<->] (-0.8,0.2) -- (0.8,0.2);
		\draw [->] (1,4.25) to[out=10,in=-270] (2.25,3.25);
	\end{tikzpicture}
	\flushright \footnotesize Fonte: \citet*{marcio:jogos} \hspace{35pt}
\end{figure}

\begin{table}[H]
	\renewcommand{\arraystretch}{1}
	\centering
	\caption{Solução obtida pelo Método do Polígono}
	\label{tab:poligono}
	\begin{tabular}{l*{10}{c}}
		\toprule
		& 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
		\midrule
		Time 1 & 6 & 4 & 2 & 5 & 3 & 6 & 4 & 2 & 5 & 3 \\
		Time 2 & 5 & 3 & 1 & 4 & 6 & 5 & 3 & 1 & 4 & 6 \\
		Time 3 & 4 & 2 & 5 & 6 & 1 & 4 & 2 & 5 & 6 & 1 \\
		Time 4 & 3 & 1 & 6 & 2 & 5 & 3 & 1 & 6 & 2 & 5 \\
		Time 5 & 2 & 6 & 3 & 1 & 4 & 2 & 6 & 3 & 1 & 4 \\
		Time 6 & 1 & 5 & 4 & 3 & 2 & 1 & 5 & 4 & 3 & 2 \\
		\bottomrule
		\multicolumn{11}{l}{\footnotesize Fonte: autores}
	\end{tabular}
\end{table}

A Tabela \ref{tab:poligono} mostra os resultados obtidos pelo Método do Polígono para $6$ times nas primeiras $n-1$ rodadas e espelhado para as $n-1$ rodadas seguintes no MDRR\footnote{Mirrored Double Round Robin}. O mesmo método pode ser aplicado aos 20 times requeridos nesse trabalho prático, para esse número de times ou qualquer outro número par de times, um polígono com $n-1$ vértices é utilizado.

\subsubsection{Segunda fase: Associando Times}

A segunda fase consiste na associação entre os times reais e os times abstratos. Para representar times abstratos usam-se as letras correspondentes aos números gerados pelo método do polígono, já os times reais são representados por números, correspondentes a ordem de seus índices.

Para essa fase, primeiro obtêm-se uma matriz quadrada de $n \times n$ oponentes consecutivos gerada partir da escala criada pelo Método do Polígono.

São considerados como ''oponentes consecutivos'' no caso em que um time $T_{k}$ possuir confrontos entre $T_{i} \times T_{k}$ e $T_{j} \times T_{k}$ em uma ou mais rodadas consecutivas, não importando a ordem dos jogos. Como exemplo, observa-se na Tabela \ref{tab:consecutivos} que os times B e E são oponentes consecutivos por 6 vezes de outros times.

\begin{table}[H]
	\renewcommand{\arraystretch}{1}
	\centering
	\caption{Oponentes consecutivos}
	\label{tab:consecutivos}
	\begin{tabular}{l*{10}{c}}
		\toprule
		& 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
		\midrule
		Time 1 & F & D & \textbf{B} & \textbf{E} & C & F & D & \textbf{B} & \textbf{E} & C \\
		Time 2 & E & C & A & D & F & E & C & A & D & F \\
		Time 3 & D & \textbf{B} & \textbf{E} & F & A & D & \textbf{B} & \textbf{E} & F & A \\
		Time 4 & C & A & F & \textbf{B} & \textbf{E} & C & A & F & \textbf{B} & \textbf{E} \\
		Time 5 & B & F & C & A & D & B & F & C & A & D \\
		Time 6 & A & E & D & C & B & A & E & D & C & B \\
		\bottomrule
		\multicolumn{11}{l}{\footnotesize Fonte: autores}
	\end{tabular}
\end{table}

A Tabela \ref{tab:matconsecutivos} demonstra a matriz quadrada de oponentes consecutivos dos jogos entre os times abstratos. Nessa matriz podemos observar que além de B e E serem oponentes consecutivos por 6 vezes, outros times também são consecutivos por uma ou mais vezes, como exemplo, C e A também são consecutivos por 6 vezes.

\begin{table}[H]
	\renewcommand{\arraystretch}{1}
	\centering
	\caption{Matriz de oponentes consecutivos para $n=6$}
	\label{tab:matconsecutivos}
	\begin{tabular}{c *{6}{C}}
		\toprule
		  & A & B & C & D & E & F \\
		A & - & 1 & 6 & 5 & 2 & 4 \\
		B & 1 & - & 2 & 5 & 6 & 4 \\
		C & 6 & 2 & - & 2 & 5 & 3 \\
		D & 5 & 5 & 2 & - & 2 & 4 \\
		E & 2 & 6 & 5 & 2 & - & 3 \\
		F & 4 & 4 & 3 & 4 & 3 & - \\
		\bottomrule
		\multicolumn{7}{l}{\footnotesize Fonte: autores}
	\end{tabular}
\end{table}

A associação, então, ocorre entre os pares de times reais que possuem a menor distância entre suas sedes com os pares de oponentes consecutivos de maior número de confrontos. Essa heurística é descrita a seguir.

Inicialmente, pares de times abstratos são ordenados em ordem decrescente conforme o número de oponentes consecutivos (Tabela \ref{tab:abstratos}). Times reais são ordenados em ordem crescente de distância em relação às sedes de seus oponentes (Tabela \ref{tab:reais}), e são associados aos times abstratos nesta ordem. Dessa forma, os times abstratos com maior número de oponentes consecutivos serão preferencialmente associados aos times reais com as distâncias entre sedes menores.

\begin{table}[H]
	\renewcommand{\arraystretch}{1}
	\centering
	\caption{Pares ordenados de times reais.}
	\label{tab:reais}
	\begin{tabular}{cclr}
		\toprule
		 1 & (2,6) & (Atlético Mineiro, Cruzeiro) & 0 Km \\
		 2 & (1,6) & (América Mineiro, Cruzeiro) & 0 Km \\
		 3 & (1,2) & (América Mineiro, Atlético Mineiro) & 0 Km \\
		 4 & (3,5) & (Atlético Paranaense, Corinthians) & 415 Km \\
		 5 & (2,4) & (Atlético Mineiro, Botafogo) & 440 Km \\
		 6 & (1,4) & (América Mineiro, Botafogo) & 440 Km \\
		 7 & (4,6) & (Botafogo, Cruzeiro) & 441 Km \\
		 8 & (4,5) & (Botafogo, Corinthians) & 444 Km \\
		 9 & (1,5) & (América Mineiro, Corinthians) & 585 Km \\
		10 & (2,5) & (Atlético Mineiro, Corinthians) & 585 Km \\
		11 & (5,6) & (Corinthians, Cruzeiro) & 587 Km \\
		12 & (3,4) & (Atlético Paranaense, Botafogo) & 849 Km \\
		13 & (1,3) & (América Mineiro, Atlético Paranaense) & 1000 Km \\
		14 & (2,3) & (Atlético Mineiro, Atlético Paranaense) & 1000 Km \\
		15 & (3,6) & (Atlético Paranaense, Cruzeiro) & 1001 Km \\
		\bottomrule
		\multicolumn{4}{l}{\footnotesize Fonte: autores}
	\end{tabular}
\end{table}

\begin{table}[H]
	\renewcommand{\arraystretch}{1}
	\centering
	\caption{Pares ordenados de times abstratos.}
	\label{tab:abstratos}
	\begin{tabular}{rcc c|c rcc c|c rcc}
		\toprule
		 1 & (E,B) & 6 &&& 11 & (D,F) & 4 &&& 21 & (D,E) & 2 \\
		 2 & (C,A) & 6 &&& 12 & (F,A) & 4 &&& 22 & (C,D) & 2 \\
		 3 & (B,E) & 6 &&& 13 & (F,D) & 4 &&& 23 & (C,B) & 2 \\
		 4 & (A,C) & 6 &&& 14 & (B,F) & 4 &&& 24 & (B,C) & 2 \\
		 5 & (E,C) & 5 &&& 15 & (A,F) & 4 &&& 25 & (E,D) & 2 \\
		 6 & (D,B) & 5 &&& 16 & (F,B) & 4 &&& 26 & (A,E) & 2 \\
		 7 & (D,A) & 5 &&& 17 & (E,F) & 3 &&& 27 & (E,A) & 2 \\
		 8 & (C,E) & 5 &&& 18 & (F,C) & 3 &&& 28 & (D,C) & 2 \\
		 9 & (B,D) & 5 &&& 19 & (F,E) & 3 &&& 29 & (B,A) & 1 \\
		10 & (A,D) & 5 &&& 20 & (C,F) & 3 &&& 30 & (A,B) & 1 \\
		\bottomrule
		\multicolumn{13}{l}{\footnotesize Fonte: autores}
	\end{tabular}
\end{table}

O pseudo-código para a heurística dessa associação é mostrado no Algorítimo \ref{alg:associa}.

\vspace{0.5cm}
\begin{algorithm}[H]
	\caption{Associa times reais à times abstratos}
	\algorithmfootnote{Fonte: \citet*{marcio:jogos}}
	\label{alg:associa}
	Entrada{Entrada}
	\Repita{todos os times reais sejam associados aos times abstratos} {
		Seja $T_{1}$ o próximo time real a ser associado a um time abstrato\\
		e seja $T_{2}$ o time, cuja cidade é mais próxima à cidade de $T_{1}$.\\
		\eSe{$T_{2}$ já foi associado} {
			Encontre o primeiro par $(a,b)$ de times abstratos, tal que $a$ esteja\\
			associado ao time $T_{2}$ e $b$ ainda não esteja associado a nenhum time real.\\
			$b \leftarrow T_{1}$ }
		{ Encontre o primeiro par $(a,b)$ de times abstratos, tal\\
			que nenhum deles esteja associado a um time real.\\
			$a \leftarrow T_{1}$ } }
\end{algorithm}
\vspace{0.5cm}

Essa heurística de associação tem como objetivo minimizar o deslocamento de um time $T_{k}$, isso baseia-se na ideia de que se existirem confrontos $T_{i} \times T_{k}$ e $T_{j} \times T_{k}$ consecutivos, a distância percorrida por $T_{k}$ seria menor caso as sedes de seus oponentes consecutivos forem próximas.

\subsubsection{Terceira fase: Mando de Campo}

Na terceira e última fase para gerar uma solução inicial, são estabelecidos os mandos de campo. Considera-se para isso a restrição de três jogos consecutivos dentro ou fora de casa, assim sendo, para gerar uma escala viável deve-se alternar o máximo possível o mando de campo.

Os mandos de campo da primeira rodada são determinados aleatoriamente, e nas rodadas seguintes até a última do primeiro turno ($n-1$), uma heurística é utilizada para determinar o mando de um jogo entre os times $T_{1}$ e $T_{2}$.

Para que a heurística possa ser usada, é preciso definir $N_{i}$ como a quantidade total de jogos consecutivos dentro ou fora de casa que um time $T_{i}$ jogou em rodadas anteriores, e a partir desse valor, o Algorítimo \ref{alg:mando} é aplicado.

\vspace{0.5cm}
\begin{algorithm}[H]
	\caption{Determina o mando de campo dos jogos}
	\algorithmfootnote{Fonte: \citet*{marcio:jogos}}
	\label{alg:mando}
	Determine, de forma aleatória, o mando de campo dos jogos da primeira rodada.\\
	\ParaCada{rodada $k = 2,3,...,(n-1)$ do primeiro turno}{
		
		\Se{$N_{2} > N_{1}$}{
			\lSe{Se $T_{2}$ jogou seu último jogo em casa}{a realização do jogo será na casa do time $T_{1}$}
			\lSe{Se $T_{2}$ jogou seu último jogo fora de casa}{a realização do jogo será na casa do time $T_{2}$}	
		}
	
		\Se{$N_{2} < N_{1}$}{
			\lSe{Se $T_{1}$ jogou seu último jogo em casa}{a realização do jogo será na casa do time $T_{2}$}
			\lSe{Se $T_{1}$ jogou seu último jogo fora de casa}{a realização do jogo será na casa do time $T_{1}$}	
		}
	
		\Se{$N_{2} = N_{1}$}{
			\lSe{$T_{1}$ jogou seu último jogo em casa e o time $T_{2}$ jogou seu último jogo fora de casa}{a realização do jogo será na casa do time $T_{2}$}
			\lSe{$T_{1}$ jogou seu último jogo fora de casa e o time $T_{2}$ jogou seu último jogo em casa}{a realização do jogo será na casa do time $T_{1}$}
			\lSenao{o mando de campo é determinado aleatoriamente}
		}
	}
	Determinar os jogos do segundo turno espelhados ao primeiro turno.\\
	Caso a escala ainda permanecer inviável, reinicie o algoritmo.
\end{algorithm}
\vspace{0.5cm}

\section{Análise de Complexidade}

A análise considerada o pior caso, e sua complexidade é definida por tempo.

As Funções utilizadas pelo programa as quais um número fixo de instruções, sejam eles $k$, são executas independente de $n$, essas classificam-se como $\mathcal{O}(1)$ ou de complexidade constante e foram ignoradas na complexidade total do programa.

A partir do escopo principal do programa, a análise é dividida pelas seguintes partes:

\begin{enumerate}
\setlength\itemsep{1pt}
	\item Alocando os dados: $ 2 \times \underbrace{n+1}_{getlines()} + \;\; 2 \times \underbrace{n(n+1)}_{allocTable()} = 2n^2 + 4n +1 $
	
	\item Obtendo os dados: $ \underbrace{n+2}_{getCLUB()} + \underbrace{n+1}_{getCITY()} + \underbrace{n+2}_{getDIST()} = 3n + 5 $
	
	\item Usando o método do polígono e imprimindo os resultados: \[ \underbrace{n-1 + (n-1)(\frac{n+2}{2})}_{initPolygon()} + \underbrace{n(n+1)}_{printEscala()} = \frac{3n^2 + 5n -4}{2} \]
	
	\item Associando os clubes: $ \underbrace{n^3 + 5n^2 + 8n + 2}_{associaClub()} $
	
	\item Copiando a escala gerada pelo polígono e definindo os mandos de campo: \[ \underbrace{n(2n-1)}_{copyTable()} + \underbrace{\frac{n^3 + 6n^2 + 12n}{4}}_{setmando()} + \underbrace{n(n+1)}_{printEscala()} = \frac{n^3 + 18n^2 + 12n}{4} \]
	
	\item Busca por profundidade: \[ 2 \times \underbrace{n(n+1)}_{allocTable()} + \underbrace{n(2n-1)}_{copyTable()} + \underbrace{n+1}_{freeMemory()} + \;\; ITER(2\underbrace{n(2n-1)}_{copyTable()} + \underbrace{\frac{n^3 + 6n^2 + 12n}{4}}_{setmando()}) \] \[ = \frac{16n^2 + 8n + 4 + ITER(n^3 + 22n^2 + 8n)}{4} \]
	
	\item Liberando a memoria e imprimindo os resultados: \[ 4 \times \underbrace{n+1}_{freeMemory()} + \underbrace{n(n+1)}_{printTabela()} + \underbrace{n+1}_{printTravel()} = n^2 + 6n + 5 \]
\end{enumerate}

Simplificando a soma das funções chamadas pelo escopo principal do programa e eliminado as constantes, a complexidade total do programa é definida pela equação: $ n^3 + 37n^2 + 45n \leqslant cn^3 \rightarrow \mathcal{O}(n^3) $.

\section{Lista das Funções}

\subsection{Funções dos Arquivos}

\begin{longtable}{>{\ttfamily}p{3cm} p{11cm} p{1cm}}
	getlines() & Retorna o numero de linhas validas de um arquivo. & $\mathcal{O}(n)$ \\
	getCLUB() & Carrega os clubes a partir do arquivo de clubes, salva os dados em \textit{struct array}. & $\mathcal{O}(n)$ \\
	getCITY() & Carrega as cidades a partir do arquivo de cidades, salva os dados em um \textit{struct array}. & $\mathcal{O}(n)$ \\
	getDIST() & Carrega as distancias a partir do arquivo de distancias, salva os dados em uma matriz alocada. & $\mathcal{O}(n)$ \\
	errFile() & Retorna a mensagem de erro caso um arquivo não for encontrado. & $\mathcal{O}(1)$ \\
	\label{tab:files}
\end{longtable}
\vspace{-0.5cm}

\subsection{Funções da Lista Encadeada Simples}

\begin{longtable}{>{\ttfamily}p{3cm} p{11cm} p{1cm}}
	create() & Inicializa uma Lista Encadeada Simples & $\mathcal{O}(1)$ \\
	atP()   & Dada a posição, retorna um nó da Lista. & $\mathcal{O}(n)$ \\
	LLmin() & Retorna um nó com o menor valor de um dado. & $\mathcal{O}(n)$ \\
	LLmax() & Retorna um nó com o maior valor de um dado. & $\mathcal{O}(n)$ \\
	LLidx() & Retorna a posição de um nó. & $\mathcal{O}(n)$ \\
	LLpsh() & Insere os dados a partir da posição cabeça. & $\mathcal{O}(1)$ \\
	LLpop() & Remove os dados a partir da posição cabeça. & $\mathcal{O}(1)$ \\
	LLdel() & Remove um nó, dado sua posição na Lista. & $\mathcal{O}(n)$ \\
	LLins() & Insere um nó, dado sua posição na Lista. & $\mathcal{O}(n)$ \\
	LLchg() & Troca a posição de dois nós. & $\mathcal{O}(n)$ \\
	LLdup() & Remove os nós com dados duplicados. & $\mathcal{O}(n)$ \\
	LLinc() & Ordena a Lista em ordem crescente. & $\mathcal{O}(n)$ \\
	LLdec() & Ordena a Lista em ordem decrescente. & $\mathcal{O}(n)$ \\
	LLprt() & Retorna a impressão da Lista. & $\mathcal{O}(n)$ \\
	LLclr()  & Libera os dados da Lista da memoria. & $\mathcal{O}(n)$ \\
	isEmpty() & Retorna se uma Lista está ou não vazia. & $\mathcal{O}(1)$ \\
	\label{tab:lista}
\end{longtable}
\vspace{-0.5cm}

\subsection{Funções de Retorno de Impressão}
	
\begin{longtable}{>{\ttfamily}p{3cm} p{11cm} p{1cm}}
	printTabela() & Retorna a impressão formatada da escala. & $\mathcal{O}(n^2)$ \\
	printEscala() & Retorna a impressão não formatada da escala.. & $\mathcal{O}(n^2)$ \\
	printTravel() & Retorna a impressão das distancias percorrida por cada um dos times. & $\mathcal{O}(n)$ \\
	printMatrix() & Retorna a impressão de uma matriz $n \times n$. & $\mathcal{O}(n^2)$ \\
	printCLUB() & Retorna a impressão não formatada do \textit{struct array} de clubes. & $\mathcal{O}(n)$ \\
	printCITY() & Retorna a impressão não formatada do \textit{struct array} de cidades. & $\mathcal{O}(n)$ \\
	\label{tab:print}
\end{longtable}
\vspace{-0.5cm}

\subsection{Funções da Solução inicial}
	
\begin{longtable}{>{\ttfamily}p{3cm} p{11cm} p{1cm}}
	initPolygon() & One-factorization para gerar uma tabela inicial valida. & $\mathcal{O}(n^2)$ \\
	associaClub() & Associa os times reais aos times abstratos conforme o pseudo-código descrito no Algorítimo \ref{alg:associa}. & $\mathcal{O}(n^3)$ \\
	changeClube() & Altera o índice dos clubes conforme a associação realizada em \texttt{associaClub()}. & $\mathcal{O}(n)$ \\
	buildCalvin() & Cria os pares de times reais para \texttt{associaClub()}. & $\mathcal{O}(n^2)$ \\
	buildHarold() & Cria os pares de times abstratos para \texttt{associaClub()}. & $\mathcal{O}(n^2)$ \\
	buildLinked() & Cria uma lista simplesmente encadeada para o controle dos times associados na \texttt{associaClub()}. & $\mathcal{O}(n)$ \\
	islinked() & Verifica se um time real já esta associado. & $\mathcal{O}(n)$ \\
	associar() & Associa times reais com abstratos na lista criada por \texttt{buildlinked()}. & $\mathcal{O}(n)$ \\
	areClubs() & Verifica se todos os times já foram associados. & $\mathcal{O}(n)$ \\
	findAT1() & Função booleana de retorno para \texttt{associaClub()}. & $\mathcal{O}(1)$ \\
	findBT1() & Função booleana de retorno para \texttt{associaClub()}. & $\mathcal{O}(1)$ \\
	\label{tab:s0}
\end{longtable}
\vspace{-0.5cm}

\subsection{Funções de Mando de Campo}

\begin{longtable}{>{\ttfamily}p{3cm} p{11cm} p{1cm}}
	setmando() & Determina o mando de campo dos times conforme o pseudo-código descrito no Algorítimo \ref{alg:mando}. & $\mathcal{O}(n^3)$ \\
	sorteia() & Determina randomicamente os mandos de campo da primeira rodada. & $\mathcal{O}(n)$ \\
	CSTMando() & Verifica se a condição de três jogos consecutivos dentro ou fora de casa foi respeitada. & $\mathcal{O}(n^2)$ \\
	espelha() & Espelha os mandos gerados no primeiro turno para o returno. & $\mathcal{O}(n^2)$ \\
	randint() & Gera um inteiro randomicamente conforme o \textit{seed} do sistema. & $\mathcal{O}(1)$ \\
	\label{tab:mando}
\end{longtable}
\vspace{-0.5cm}

\subsection{Funções Gerais}

\begin{longtable}{>{\ttfamily}p{3cm} p{11cm} p{1cm}}
	allocTable() & Aloca uma matriz de ponteiros. & $O(n^2)$ \\
	freeMemory() & Libera a memoria alocada por \texttt{allocTable()}. & $O(n)$ \\
	copyTable() & Copia dados entre matrizes. & $O(n^2)$ \\
	shiftArray() & Movimenta os dados em um array (\textit{shift}). & $O(1)$ \\
	viagem() & Retorna a distancia entre as sedes dos times. & $O(1)$ \\
	custos() & Calcula e retorna os custos totais de uma escala de jogos gerada, assim como o custo de deslocamento individual dos times. & $O(n^2)$ \\
	timeresult() & Retorna o tempo de execução até determinado ponto. & $O(1)$ \\
	wait() & Função de espera (pausa o tempo de execução por $n$ segundos). & $\mathcal{O}(n)$ \\
	ask() & Espera por uma entrada fornecida pelo usuário. & $\mathcal{O}(n)$ \\
	\label{tab:comum}
\end{longtable}

\section{Análise de Resultados}

\begin{table}[H]
	\renewcommand{\arraystretch}{1}
	\centering
	\caption{Análise dos resultados.}
	\label{tab:resultados}
	\begin{tabular}{*{6}{c} r}
		\toprule 
		$S_{0}$ & $S_{k}$ & $k$ & Tentativas & Tempo & Diferença \% & Ganho \\ 
		\midrule
		837635 & 784889 &  3 & 19698 & 1s 903ms &  6.30\% &  52746 \\
		848148 & 790269 & 10 & 18519 & 1s 795ms &  6.82\% &  57879 \\
		814842 & 772594 &  9 & 19458 & 1s 892ms &  5.18\% &  42248 \\
		864708 & 782358 &  5 & 18773 & 1s 823ms &  9.52\% &  82350 \\
		858557 & 780693 &  8 & 19692 & 1s 910ms &  9.07\% &  77864 \\
		858637 & 755076 &  9 & 19651 & 1s 912ms & 12.06\% & 103561 \\
		840565 & 781085 &  4 & 20540 & 1s 984ms &  7.08\% &  59480 \\
		825463 & 781733 &  6 & 18880 & 1s 830ms &  5.30\% &  43730 \\
		848581 & 772612 &  9 & 19195 & 1s 862ms &  8.95\% &  75969 \\
		844549 & 770172 &  8 & 18408 & 1s 791ms &  8.81\% &  74377 \\
		865979 & 779945 &  6 & 20467 & 1s 985ms &  9.93\% &  86034 \\
		857004 & 767938 &  5 & 19898 & 1s 928ms & 10.39\% &  89066 \\
		795849 & 774157 &  3 & 19754 & 1s 914ms &  2.73\% &  21692 \\
		862298 & 769219 &  8 & 18952 & 1s 846ms & 10.79\% &  93079 \\
		842242 & 777349 &  4 & 19309 & 1s 868ms &  7.70\% &  64893 \\
		\midrule
		844337 & 776005 &    &       &          &  8.042\% &  68331.6 \\
		\bottomrule
		\multicolumn{6}{l}{\footnotesize Fonte: autores}
	\end{tabular}
\end{table}

Mediante a análise de resultados obtidos, pode-se perceber a vantagem do uso de um método heurístico como o de LNS (Large Neighborhood Search), que é baseado no princípio de destruição e reconstrução de rotas. Onde utilizamos a primeira tabela gerada pelo método de 3 fases, a reorganizando K vezes, de forma a construir uma nova melhor. 

Na tabela acima temos então que S(0) é o valor inicial obtido, referente a distância em km que os times irão percorrer durante a realização do campeonato, e S(K) o valor da distância prevista após a aplicação do método heurístico. 

Portanto a abordagem proporciona uma melhora significativa na resolução do problema, onde em média existe uma redução de aproximadamente 8.05\% na distância total a ser percorrida pelos times. 

Contudo, sabendo que normalmente os clubes de futebol fretam aviões para transportar seus jogadores; e tendo em mente que o querosene de aviação (QAV)\cite{ttp:qav} possui o preço atual de R\$3,30 o litro, e que um avião adequado para acomodar um time de futebol, viaja a 880km por hora utilizando em média 8,09 litros por quilômetro\cite{ttp:rendimento}. Podemos concluir que com o uso dessa heurística, a redução de 68.332km de viagem durante o campeonato resultariam na economia de R\$1.824.259 e 78 horas de viagem. 

Desta forma pode-se traduzir para o cenário das competições brasileiras que não só seriam reduzidos os de gastos dos clubes, mas também os jogadores sofreriam de um desgaste menor entre as partidas.

\pagebreak

\begin{flushleft}
	\nocite{*}
	\bibliography{TTP}
	\vfill
	O histórico do desenvolvimento desse trabalho se encontra online em:\\ \url{https://github.com/Durfan/ufsj-aeds3-tp2}.
\end{flushleft}

\end{document}
