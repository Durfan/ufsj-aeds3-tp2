\documentclass[12pt,a4paper]{article}

\usepackage[left=3.00cm, right=2.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}

\usepackage{indentfirst}
\usepackage{setspace}
\onehalfspacing

\usepackage[numbers]{natbib}
\usepackage{url}
\bibliographystyle{plainnat}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}

\usepackage{longtable}
\usepackage{booktabs}
\usepackage{float}

\usepackage{tikz}
\usepackage[portuguese, ruled]{algorithm2e}

\makeatletter
\newcommand{\algorithmfootnote}[2][\footnotesize]{%
	\let\old@algocf@finish\@algocf@finish% Store algorithm finish macro
	\def\@algocf@finish{\old@algocf@finish% Update finish macro to insert "footnote"
		\leavevmode\rlap{\begin{minipage}{\linewidth}
				#1#2
		\end{minipage}}%
	}%
}
\makeatother

\usepackage{array}
\newcolumntype{C}{>{\centering\arraybackslash}p{1cm}}
\renewcommand*{\arraystretch}{1.2}

\author{Pablo Cecilio Oliveira\\
	Alexander Cristian}
\title{Algorítimos e Estrutura de Dados III\\
O Problema da Viagem do Torneio}
\date{}

\begin{document}
\maketitle

\section{Introdução}

O Problema da Viagem do Torneio Viajante (Traveling Tournament Problem) pode ser considerado como um problema de otimização matemática que envolve a criação de uma escala de jogos em um torneio viável.

A viabilidade da escala é definida de maneira geral por dois  outros problemas. O primeiro é uma questão de viabilidade, o padrão de jogos em casa e longe deve ser suficientemente variado, de modo a evitar padrões de estadia e deslocamento excessivos. O segundo é uma questão de deslocamento, onde buscasse minimizar o custo total de deslocamento com objetivo de evitar viagens excessivas.

Neste trabalho prático é apresentado uma solução para o TTP do Campeonato Brasileiro de Futebol.

A escala de jogos do Campeonato Brasileiro de Futebol consiste em definir uma escala de jogos viável entre $n$ times divididos em $n-1$ rodadas $k$ no primeiro turno, onde cada time joga com cada um dos outros sem repetições, e sem que existam mais que três jogos consecutivos fora de casa. Para o returno na rodada $k + (n - 1)$, os jogos são espelhados do primeiro turno, porem com o mando de campo invertido.

Na solução final para o problema, o custo de deslocamento dos times na escala de jogos deve ser considerado e seu retorno minimizado.

\section{Implementação}

Para a construção de uma solução inicial, utiliza-se o método de três fases proposto por Ribeiro e Urrutia (2004a)\cite{urrutia:heuristics}.

\subsection{Método de três fases para geração de uma solução inicial}

\subsubsection{Primeira fase: Método do Polígono}

A primeira fase da solução inicial consiste em uma fatoração que utiliza o Método do Polígono. Nesse método, sendo $n$ o número de times participantes do campeonato, forma-se um polígono com $n-1$ nós numerados e um $n$-ésimo time é atribuído a um nó fora desse polígono.

A cada rodada, os times localizados nos nós $k=2,3,...,n/2$ jogam contra os times localizados nos nós $n+1-k$, o $n$-ésimo time localizado fora do polígono joga contra o time localizado no primeiro nó do polígono. Para as $n-1$ rodadas seguintes, o polígono é movido em sentido horário para determinar os novos jogos. A Figura \ref{poligono}, demonstra a fatoração para as três primeiras rodadas de um campeonato com $6$ times.

\begin{figure}[H]
	\centering
	\caption{Método do Polígono para três primeiras rodadas com n = 6}
	\label{poligono}
	\vspace{.6cm}
	\begin{tikzpicture}
		\tikzstyle{every node}=[draw, shape=circle, inner sep=4pt];
		\tikzstyle{every path}=[draw, line width=0.4mm];
		\node (F) at (0,6) {$6$};
		\node (A) at (0,4) {$1$};
		\node (B) at (2,2.25) {$2$};
		\node (C) at (1.25,0) {$3$};
		\node (D) at (-1.25,0) {$4$};
		\node (E) at (-2,2.25) {$5$};
		\draw (A)--(B)--(C)--(D)--(E)--(A);
		\draw [<->] (0,5.5) -- (0,4.5);
		\draw [<->] (-1.5,2.25) -- (1.5,2.25);
		\draw [<->] (-0.8,0.2) -- (0.8,0.2);
	\end{tikzpicture}
	\hfil
	\begin{tikzpicture}
		\tikzstyle{every node}=[draw, shape=circle, inner sep=4pt];
		\tikzstyle{every path}=[draw, line width=0.4mm];
		\node (F) at (0,6) {$6$};
		\node (A) at (0,4) {$5$};
		\node (B) at (2,2.25) {$1$};
		\node (C) at (1.25,0) {$2$};
		\node (D) at (-1.25,0) {$3$};
		\node (E) at (-2,2.25) {$4$};
		\draw (A)--(B)--(C)--(D)--(E)--(A);
		\draw [<->] (0,5.5) -- (0,4.5);
		\draw [<->] (-1.5,2.25) -- (1.5,2.25);
		\draw [<->] (-0.8,0.2) -- (0.8,0.2);
		\draw [->] (1,4.25) to[out=10,in=-270] (2.25,3.25);
	\end{tikzpicture}
	\hfil
	\begin{tikzpicture}
		\tikzstyle{every node}=[draw, shape=circle, inner sep=4pt];
		\tikzstyle{every path}=[draw, line width=0.4mm];
		\node (F) at (0,6) {$6$};
		\node (A) at (0,4) {$4$};
		\node (B) at (2,2.25) {$5$};
		\node (C) at (1.25,0) {$1$};
		\node (D) at (-1.25,0) {$2$};
		\node (E) at (-2,2.25) {$3$};
		\draw (A)--(B)--(C)--(D)--(E)--(A);
		\draw [<->] (0,5.5) -- (0,4.5);
		\draw [<->] (-1.5,2.25) -- (1.5,2.25);
		\draw [<->] (-0.8,0.2) -- (0.8,0.2);
		\draw [->] (1,4.25) to[out=10,in=-270] (2.25,3.25);
	\end{tikzpicture}
	\vspace{.3cm}\\
	\footnotesize Fonte: \Citeauthor{marcio:jogos} \Citep{marcio:jogos}
\end{figure}

\begin{table}[H]
	\centering
	\caption{Solução obtida pelo Método do Polígono}
	\label{tab:poligono}
	\begin{tabular}{l*{10}{c}}
		\toprule
		& 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
		\midrule
		Time 1 & 6 & 4 & 2 & 5 & 3 & 6 & 4 & 2 & 5 & 3 \\
		Time 2 & 5 & 3 & 1 & 4 & 6 & 5 & 3 & 1 & 4 & 6 \\
		Time 3 & 4 & 2 & 5 & 6 & 1 & 4 & 2 & 5 & 6 & 1 \\
		Time 4 & 3 & 1 & 6 & 2 & 5 & 3 & 1 & 6 & 2 & 5 \\
		Time 5 & 2 & 6 & 3 & 1 & 4 & 2 & 6 & 3 & 1 & 4 \\
		Time 6 & 1 & 5 & 4 & 3 & 2 & 1 & 5 & 4 & 3 & 2 \\
		\bottomrule
		\footnotesize Fonte: autores
	\end{tabular}
\end{table}

A Tabela \ref{tab:poligono} mostra os resultados obtidos pelo Método do Polígono para $6$ times nas primeiras $n-1$ rodadas e espelhado para as $n-1$ rodadas seguintes no MDRR. O mesmo método pode ser aplicado aos 20 times requeridos nesse trabalho prático, para esse número de times ou qualquer outro número par de times, um polígono com $n-1$ vértices é utilizado.

\subsubsection{Segunda fase: Associando Times}

A segunda fase consiste na associação entre os times reais e os times abstratos. Para representar times abstratos usam-se as letras correspondentes aos números gerados pelo método do polígono, já os times reais são representados por números, correspondentes a ordem de seus índices.

Para essa fase, primeiro obtêm-se uma matriz quadrada de $n \times n$ oponentes consecutivos gerada partir da escala criada pelo Método do Polígono.

São considerados como ''oponentes consecutivos'' no caso em que um time $T_{k}$ possuir confrontos entre $T_{i} \times T_{k}$ e $T_{j} \times T_{k}$ em uma ou mais rodadas consecutivas, não importando a ordem dos jogos. Como exemplo, observa-se na Tabela \ref{tab:consecutivos} que os times B e E são oponentes consecutivos por 6 vezes de outros times.

\begin{table}[H]
	\centering
	\caption{Oponentes consecutivos}
	\label{tab:consecutivos}
	\begin{tabular}{l*{10}{c}}
		\toprule
		& 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
		\midrule
		Time 1 & F & D & \textbf{B} & \textbf{E} & C & F & D & \textbf{B} & \textbf{E} & C \\
		Time 2 & E & C & A & D & F & E & C & A & D & F \\
		Time 3 & D & \textbf{B} & \textbf{E} & F & A & D & \textbf{B} & \textbf{E} & F & A \\
		Time 4 & C & A & F & \textbf{B} & \textbf{E} & C & A & F & \textbf{B} & \textbf{E} \\
		Time 5 & B & F & C & A & D & B & F & C & A & D \\
		Time 6 & A & E & D & C & B & A & E & D & C & B \\
		\bottomrule
		\footnotesize Fonte: autores
	\end{tabular}
\end{table}

A Tabela \ref{tab:matconsecutivos} demonstra a matriz quadrada de oponentes consecutivos dos jogos entre os times abstratos. Nessa matriz podemos observar que além de B e E serem oponentes consecutivos por 6 vezes, outros times também são consecutivos por uma ou mais vezes, como exemplo, C e A também são consecutivos por 6 vezes.

\begin{table}[H]
	\centering
	\caption{Matriz de oponentes consecutivos para $n=6$}
	\label{tab:matconsecutivos}
	\begin{tabular}{c *{6}{C}}
		\toprule
		  & A & B & C & D & E & F \\
		A & 0 & 1 & 6 & 5 & 2 & 4 \\
		B & 1 & 0 & 2 & 5 & 6 & 4 \\
		C & 6 & 2 & 0 & 2 & 5 & 3 \\
		D & 5 & 5 & 2 & 0 & 2 & 4 \\
		E & 2 & 6 & 5 & 2 & 0 & 3 \\
		F & 4 & 4 & 3 & 4 & 3 & 0 \\
		\bottomrule
	\end{tabular}
	\vspace{0.2cm}\\
	\footnotesize Fonte: autores
\end{table}

A associação, então, ocorre entre os pares de times reais que possuem a menor distância entre suas sedes com os pares de oponentes consecutivos de maior número de confrontos. Essa heurística é descrita a seguir.

Inicialmente, pares de times abstratos são ordenados em ordem decrescente conforme o número de oponentes consecutivos (Tabela \ref{tab:abstratos}). Times reais são ordenados em ordem crescente de distância em relação às sedes de seus oponentes (Tabela \ref{tab:reais}), e são associados aos times abstratos nesta ordem. Dessa forma, os times abstratos com maior número de oponentes consecutivos serão preferencialmente associados aos times reais com as distâncias entre sedes menores.

\begin{table}[H]
	\renewcommand{\arraystretch}{1}
	\centering
	\caption{Pares ordenados de times reais.}
	\label{tab:reais}
	\vspace{0.2cm}
	\begin{tabular}{cclr}
		\toprule
		 1 & (2,6) & (Atlético Mineiro, Cruzeiro) & 0 Km \\
		 2 & (1,6) & (América Mineiro, Cruzeiro) & 0 Km \\
		 3 & (1,2) & (América Mineiro, Atlético Mineiro) & 0 Km \\
		 4 & (3,5) & (Atlético Paranaense, Corinthians) & 415 Km \\
		 5 & (2,4) & (Atlético Mineiro, Botafogo) & 440 Km \\
		 6 & (1,4) & (América Mineiro, Botafogo) & 440 Km \\
		 7 & (4,6) & (Botafogo, Cruzeiro) & 441 Km \\
		 8 & (4,5) & (Botafogo, Corinthians) & 444 Km \\
		 9 & (1,5) & (América Mineiro, Corinthians) & 585 Km \\
		10 & (2,5) & (Atlético Mineiro, Corinthians) & 585 Km \\
		11 & (5,6) & (Corinthians, Cruzeiro) & 587 Km \\
		12 & (3,4) & (Atlético Paranaense, Botafogo) & 849 Km \\
		13 & (1,3) & (América Mineiro, Atlético Paranaense) & 1000 Km \\
		14 & (2,3) & (Atlético Mineiro, Atlético Paranaense) & 1000 Km \\
		15 & (3,6) & (Atlético Paranaense, Cruzeiro) & 1001 Km \\
		\bottomrule
	\end{tabular}
	\vspace{0.2cm}\\
	\footnotesize Fonte: autores
\end{table}

\begin{table}[H]
	\centering
	\caption{Pares ordenados de times abstratos.}
	\label{tab:abstratos}
	\vspace{0.2cm}
	\begin{tabular}{rcc c|c rcc c|c rcc}
		\toprule
		 1 & (E,B) & 6 &&& 11 & (D,F) & 4 &&& 21 & (D,E) & 2 \\
		 2 & (C,A) & 6 &&& 12 & (F,A) & 4 &&& 22 & (C,D) & 2 \\
		 3 & (B,E) & 6 &&& 13 & (F,D) & 4 &&& 23 & (C,B) & 2 \\
		 4 & (A,C) & 6 &&& 14 & (B,F) & 4 &&& 24 & (B,C) & 2 \\
		 5 & (E,C) & 5 &&& 15 & (A,F) & 4 &&& 25 & (E,D) & 2 \\
		 6 & (D,B) & 5 &&& 16 & (F,B) & 4 &&& 26 & (A,E) & 2 \\
		 7 & (D,A) & 5 &&& 17 & (E,F) & 3 &&& 27 & (E,A) & 2 \\
		 8 & (C,E) & 5 &&& 18 & (F,C) & 3 &&& 28 & (D,C) & 2 \\
		 9 & (B,D) & 5 &&& 19 & (F,E) & 3 &&& 29 & (B,A) & 1 \\
		10 & (A,D) & 5 &&& 20 & (C,F) & 3 &&& 30 & (A,B) & 1 \\
		\bottomrule
	\end{tabular}
	\vspace{0.2cm}\\
	\footnotesize Fonte: autores
\end{table}

O pseudo-código para a heurística dessa associação é mostrado no Algorítimo \ref{alg:associa}.

\vspace{0.5cm}
\begin{algorithm}[H]
	\caption{Associa times reais à times abstratos}
	\algorithmfootnote{Fonte: \Citeauthor{marcio:jogos} \Citep{marcio:jogos}}
	\label{alg:associa}
	\Repita{todos os times reais sejam associados aos times abstratos} {
		Seja $T_{1}$ o próximo time real a ser associado a um time abstrato\\
		e seja $T_{2}$ o time, cuja cidade é mais próxima à cidade de $T_{1}$.\\
		\eSe{$T_{2}$ já foi associado} {
			Encontre o primeiro par $(a,b)$ de times abstratos, tal que $a$ esteja\\
			associado ao time $T_{2}$ e $b$ ainda não esteja associado a nenhum time real.\\
			$b \leftarrow T_{1}$ }
		{ Encontre o primeiro par $(a,b)$ de times abstratos, tal\\
			que nenhum deles esteja associado a um time real.\\
			$a \leftarrow T_{1}$ } }
\end{algorithm}
\vspace{0.5cm}

Essa associação tem como objetivo minimizar o deslocamento de um time $T_{k}$, baseando-se na ideia de que se existirem confrontos $T_{i} \times T_{k}$ e $T_{j} \times T_{k}$ consecutivos, a distância percorrida por $T_{k}$ seria menor caso suas sedes forem próximas.

\subsubsection{Terceira fase: Mando de Campo}

Na terceira e última fase para gerar uma solução inicial, são estabelecidos os mandos de campo. Considera-se para isso a restrição de três jogos consecutivos dentro ou fora de casa, assim sendo, para gerar uma escala viável deve-se alternar o máximo possível o mando de campo.

Os mandos de campo da primeira rodada são determinados aleatoriamente, e nas rodadas seguintes até a última do primeiro turno ($n-1$), uma heurística é utilizada para determinar o mando de um jogo entre os times $T_{1}$ e $T_{2}$.

Para que a heurística possa ser usada, é preciso definir $N_{i}$ como a quantidade total de jogos consecutivos dentro ou fora de casa que um time $T_{i}$ jogou em rodadas anteriores, e a partir desse valor, o algorítimo \ref{alg:mando} é aplicado.

\vspace{0.5cm}
\begin{algorithm}[H]
	\caption{Determina o mando de campo dos jogos}
	\algorithmfootnote{Fonte: \Citeauthor{marcio:jogos} \Citep{marcio:jogos}}
	\label{alg:mando}
	Determine, de forma aleatória, o mando de campo dos jogos da primeira rodada.\\
	\ParaCada{rodada $k = 2,3,...,(n-1)$ do primeiro turno}{
		
		\Se{$N_{2} > N_{1}$}{
			\lSe{Se $T_{2}$ jogou seu último jogo em casa}{a realização do jogo será na casa do time $T_{1}$}
			\lSe{Se $T_{2}$ jogou seu último jogo fora de casa}{a realização do jogo será na casa do time $T_{2}$}	
		}
	
		\Se{$N_{2} < N_{1}$}{
			\lSe{Se $T_{1}$ jogou seu último jogo em casa}{a realização do jogo será na casa do time $T_{2}$}
			\lSe{Se $T_{1}$ jogou seu último jogo fora de casa}{a realização do jogo será na casa do time $T_{1}$}	
		}
	
		\Se{$N_{2} = N_{1}$}{
			\lSe{$T_{1}$ jogou seu último jogo em casa e o time $T_{2}$ jogou seu último jogo fora de casa}{a realização do jogo será na casa do time $T_{2}$}
			\lSe{$T_{1}$ jogou seu último jogo fora de casa e o time $T_{2}$ jogou seu último jogo em casa}{a realização do jogo será na casa do time $T_{1}$}
			\lSenao{o mando de campo é determinado aleatoriamente}
		}
	}
	Determinar os jogos do segundo turno espelhados ao primeiro turno.\\
	Caso a escala ainda permanecer inviável, reinicie o algoritmo.
\end{algorithm}

\section{Análise de complexidade}

A análise feita é considerada para o pior caso, e sua complexidade é definida por tempo.

As Funções utilizadas pelo programa as quais um número fixo de instruções, sejam eles $k$, são executas independente de $n$, essas classificam-se como $\mathcal{O}(1)$ ou de complexidade constante. Dentre as listadas nas seções seguintes, se encontram:

\begin{itemize}
	\setlength\itemsep{1pt}
	\item Funções que retornam uma condição booleana; 
	\item Inicialização da Lista Simplesmente Encadeada;
	\item Inserção ou remoção de um nó a partir do nó ''cabeça'' de uma Lista Simplesmente Encadeada;
	\item Funções de retorno de impressão para mensagens de erro, ou para o retorno de impressão do tempo decorrido até determinado ponto relativo ao código;
	\item A Função que realiza a copia de um trecho de memória, ou a que retorna um conteúdo endereçado diretamente para uma área de memoria;
	\item A Função que gera números randômicos através do seed fornecido pelo sistema.
\end{itemize}

As Funções analisadas como sendo de complexidade linear, ou $\mathcal{O}(n)$, tais que $n$ mais um número fixo de instruções são menores do que $cn$ ($f(n) = (n+1) \Rightarrow (n+1) \leqslant cn$). Essas compõe a maioria do programa e são listadas de forma geral a seguir:

\begin{itemize}
	\setlength\itemsep{1pt}
	\item A Função que retorna um o numero de linhas de um arquivo;
	\item Funções que carregam os dados dos arquivos para estruturas de dados;
	\item Funções que carregam os dados dos arquivos para estruturas de dados;
	\item Funções de uso geral da Lista Simplesmente Encadeada:
	\begin{itemize}
		\setlength\itemsep{1pt}
		\item Funções que retorna um nó que contem um menor valor de um dado, ou a que retorna um nó que contem o maior valor de um dado;
		\item Função que retorna a posição de um nó na lista;
		\item Funções que carregam os dados dos arquivos para estruturas de dados;
		\item Funções que removem ou inserem um nó da Lista conforme sua posição;
		\item Função que troca as posições de dois nós;
		\item Função que remove nós com dados duplicados;
		\item Funções que ordenam a lista em ordem crescente ou decrescente;
		\item Função que retorna a impressão da Lista;
		\item Função que libera os dados da Lista da memoria
	\end{itemize}
	\item Funções de de retorno de impressão do struct array de clubes ou de cidades;
	\item Função que altera os índices do struct array de clubes;
	\item As Funções de manuseio da Lista Encadeada criada como auxilio a função\\ \texttt{associaClub()};
	\item A Função de alocação de uma matriz de ponteiros;
	\item A Função que libera a memoria alocada por uma matriz;
	\item A Funções de espera por tempo ou por input;
\end{itemize}

As Funções analisadas como sendo de complexidade quadrática, assim como as funções analisadas como complexidade cúbica definem e compõe a solução do problema da geração de uma escala viável no programa apresentado. 

Funções $\mathcal{O}(n^2)$, onde $f(n) = (n+1)^2 \Rightarrow (n+1)^2 \leqslant cn^2$ :

\begin{itemize}
	\setlength\itemsep{1pt}
	\item Funções que retornam a impressão de 2d arrays; 
	\item Função que gera uma escala pelo Método do Polígono;
	\item As funções que criam as listas de pares de times reais e abstratos para a função associaClub();
	\item A Função que verifica a restrição de jogos consecutivos dentro ou fora de casa;
	\item A Função espelha o mando de campo gerado no primeiro turno;
	\item A Função que copia um 2d array para outro 2d array;
	\item A Função que retorna os custos das distancias da escala criada.
\end{itemize}

Funções $\mathcal{O}(n^3)$, onde $f(n) = n(n+1)^2 \Rightarrow n(n+1)^2 \leqslant cn^3$ :

\begin{itemize}
	\setlength\itemsep{1pt}
	\item Função que associa times reais aos times abstratos conforme o pseudo-código do Algorítimo \ref{alg:associa}; 
	\item Função que determina o mando de campo dos times conforme o pseudo-código descrito no Algorítimo \ref{alg:mando};
\end{itemize}

\subsection{Funções de arquivos para os dados}

\begin{longtable}{p{3cm} p{11cm} p{1cm}}
	\texttt{getlines()} & Retorna o numero de linhas validas de um arquivo. & $\mathcal{O}(n)$ \\
	\texttt{getCLUB()} & Carrega os clubes a partir do arquivo de clubes, salva os dados em array struct. & $\mathcal{O}(n)$ \\
	\texttt{getCITY()} & Carrega as cidades a partir do arquivo de cidades, salva os dados em um array struct. & $\mathcal{O}(n)$ \\
	\texttt{getDIST()} & Carrega as distancias a partir do arquivo de distancias, salva os dados em uma matriz alocada. & $\mathcal{O}(n)$ \\
	\texttt{errFile()} & Retorna a msg de erro caso o arquivo não for encontrado. & $\mathcal{O}(1)$ \\
	\label{tab:files}
\end{longtable}
\vspace{-0.5cm}

\subsection{Funções da Lista Encadeada Simples}

\begin{longtable}{p{3cm} p{11cm} p{1cm}}
	\texttt{create()} & Inicializa uma Lista Encadeada Simples & $\mathcal{O}(1)$ \\
	\texttt{atP()} & Dada a posição, retorna um nó da Lista. & $\mathcal{O}(n)$ \\
	\texttt{LLmin()} & Retorna um nó com o menor valor de um dado. & $\mathcal{O}(n)$ \\
	\texttt{LLmax()} & Retorna um nó com o maior valor de um dado. & $\mathcal{O}(n)$ \\
	\texttt{LLidx()} & Retorna a posição de um nó. & $\mathcal{O}(n)$ \\
	\texttt{LLpsh()} & Insere os dados a partir da posição cabeça. & $\mathcal{O}(1)$ \\
	\texttt{LLpop()} & Remove os dados a partir da posição cabeça. & $\mathcal{O}(1)$ \\
	\texttt{LLdel()} & Remove um nó, dado sua posição na Lista. & $\mathcal{O}(n)$ \\
	\texttt{LLins()} & Insere um nó, dado sua posição na Lista. & $\mathcal{O}(n)$ \\
	\texttt{LLchg()} & Troca a posição de dois nós. & $\mathcal{O}(n)$ \\
	\texttt{LLdup()} & Remove os nós com dados duplicados. & $\mathcal{O}(n)$ \\
	\texttt{LLinc()} & Ordena a Lista em ordem crescente. & $\mathcal{O}(n)$ \\
	\texttt{LLdec()} & Ordena a Lista em ordem decrescente. & $\mathcal{O}(n)$ \\
	\texttt{LLprt()} & Retorna a impressão da Lista. & $\mathcal{O}(n)$ \\
	\texttt{LLclr()} & Libera os dados da Lista da memoria. & $\mathcal{O}(n)$ \\
	\texttt{isEmpty()} & Retorna se uma Lista está ou não vazia. & $\mathcal{O}(1)$ \\
	\label{tab:lista}
\end{longtable}
\vspace{-0.5cm}

\subsection{Funções de Retorno de Impressão}
	
\begin{longtable}{p{3cm} p{11cm} p{1cm}}
	\texttt{printTabela()} & Retorna a impressão formatada da escala. & $\mathcal{O}(n^2)$ \\
	\texttt{printEscala()} & Retorna a impressão não formatada da escala.. & $\mathcal{O}(n^2)$ \\
	\texttt{printTravel()} & Retorna a impressão das distancias percorrida por cada um dos times. & $\mathcal{O}(n)$ \\
	\texttt{printMatrix()} & Retorna a impressão de uma matriz $n \times n$. & $\mathcal{O}(n^2)$ \\
	\texttt{printCLUB()} & Retorna a impressão não formatada do array struct de clubes. & $\mathcal{O}(n)$ \\
	\texttt{printCITY()} & Retorna a impressão não formatada do array struct de cidades. & $\mathcal{O}(n)$ \\
	\label{tab:print}
\end{longtable}
\vspace{-0.5cm}

\subsection{Funções da Solução inicial}
	
\begin{longtable}{p{3cm} p{11cm} p{1cm}}
	\texttt{initPolygon()} & One-factorization para gerar uma tabela inicial valida. & $\mathcal{O}(n^2)$ \\
	\texttt{associaClub()} & Associa os times reais aos times abstratos conforme o pseudo-código descrito no Algorítimo \ref{alg:associa}. & $\mathcal{O}(n^3)$ \\
	\texttt{changeClube()} & Altera o índice dos clubes conforme a associação realizada em \texttt{associaClub()}. & $\mathcal{O}(n)$ \\
	\texttt{buildCalvin()} & Cria os pares de times reais para \texttt{associaClub()}. & $\mathcal{O}(n^2)$ \\
	\texttt{buildHarold()} & Cria os pares de times abstratos para \texttt{associaClub()}. & $\mathcal{O}(n^2)$ \\
	\texttt{buildLinked()} & Cria uma lista simplesmente encadeada para o controle dos times associados na \texttt{associaClub()}. & $\mathcal{O}(n)$ \\
	\texttt{islinked()} & Verifica se um time real já esta associado. & $\mathcal{O}(n)$ \\
	\texttt{associar()} & Associa times reais com abstratos na lista criada por \texttt{buildlinked()}. & $\mathcal{O}(n)$ \\
	\texttt{areClubs()} & Verifica se todos os times já foram associados. & $\mathcal{O}(n)$ \\
	\texttt{findAT1()} & Função booleana de retorno para \texttt{associaClub()}. & $\mathcal{O}(1)$ \\
	\texttt{findBT1()} & Função booleana de retorno para \texttt{associaClub()}. & $\mathcal{O}(1)$ \\
	\label{tab:s0}
\end{longtable}
\vspace{-0.5cm}

\subsection{Funções de Mando de Campo}

\begin{longtable}{p{3cm} p{11cm} p{1cm}}
	\texttt{setmando()} & Determina o mando de campo dos times conforme o pseudo-código descrito no Algorítimo \ref{alg:mando}. & $\mathcal{O}(n^3)$ \\
	\texttt{sorteia()} & Determina randomicamente os mandos de campo da primeira rodada. & $\mathcal{O}(n)$ \\
	\texttt{CSTMando()} & Verifica se a condição de três jogos consecutivos dentro ou fora de casa foi respeitada. & $\mathcal{O}(n^2)$ \\
	\texttt{espelha()} & Espelha os mandos gerados no primeiro turno para o returno. & $\mathcal{O}(n^2)$ \\
	\texttt{randint()} & Gera um inteiro randomicamente conforme o seed do sistema. & $\mathcal{O}(1)$ \\
	\label{tab:mando}
\end{longtable}
\vspace{-0.5cm}

\subsection{Funções de uso comum ao programa}

\begin{longtable}{p{3cm} p{11cm} p{1cm}}
	\texttt{allocTable()} & Aloca uma matriz de ponteiros. & $O(n)$ \\
	\texttt{freeMemory()} & Libera a memoria alocada por \texttt{allocTable()}. & $O(n)$ \\
	\texttt{copyTable()} & Copia dados entre matrizes. & $O(n^2)$ \\
	\texttt{shiftArray()} & Movimenta os dados em um array (shift). & $O(1)$ \\
	\texttt{viagem()} & Retorna a distancia entre as sedes dos times. & $O(1)$ \\
	\texttt{custos()} & Calcula e retorna os custos totais de uma escala de jogos gerada, assim como o custo de deslocamento individual dos times. & $O(n^2)$ \\
	\texttt{timeresult()} & Retorna o tempo de execução até determinado ponto. & $O(1)$ \\
	\texttt{wait()} & Função de espera (pausa o tempo de execução por $n$ segundos). & $O(n)$ \\
	\texttt{ask()} & Espera por um input fornecido pelo usuário. & $O(n)$ \\
	\label{tab:comum}
\end{longtable}

\section{Análise de resultados}

\begin{table}[H]
	\centering
	\caption{Análise dos resultados.}
	\label{tab:resultados}
	\vspace{0.2cm}
	\begin{tabular}{ccccccr}
		\toprule 
		$S_{0}$ & $S_{k}$ & $k$ & Tentativas & Tempo & Diferença \% & Ganho \\ 
		\midrule
		837635 & 784889 &  3 & 19698 & 1s 903ms &  6.30\% &  52746 \\
		848148 & 790269 & 10 & 18519 & 1s 795ms &  6.82\% &  57879 \\
		814842 & 772594 &  9 & 19458 & 1s 892ms &  5.18\% &  42248 \\
		864708 & 782358 &  5 & 18773 & 1s 823ms &  9.52\% &  82350 \\
		858557 & 780693 &  8 & 19692 & 1s 910ms &  9.07\% &  77864 \\
		858637 & 755076 &  9 & 19651 & 1s 912ms & 12.06\% & 103561 \\
		840565 & 781085 &  4 & 20540 & 1s 984ms &  7.08\% &  59480 \\
		825463 & 781733 &  6 & 18880 & 1s 830ms &  5.30\% &  43730 \\
		848581 & 772612 &  9 & 19195 & 1s 862ms &  8.95\% &  75969 \\
		844549 & 770172 &  8 & 18408 & 1s 791ms &  8.81\% &  74377 \\
		865979 & 779945 &  6 & 20467 & 1s 985ms &  9.93\% &  86034 \\
		857004 & 767938 &  5 & 19898 & 1s 928ms & 10.39\% &  89066 \\
		795849 & 774157 &  3 & 19754 & 1s 914ms &  2.73\% &  21692 \\
		862298 & 769219 &  8 & 18952 & 1s 846ms & 10.79\% &  93079 \\
		842242 & 777349 &  4 & 19309 & 1s 868ms &  7.70\% &  64893 \\
		\midrule
		844337 & 776005 &    &       &          &  8.09\% &  68332 \\
		\bottomrule
		\footnotesize Fonte: autores
	\end{tabular}
\end{table}

\pagebreak

\begin{flushleft}
	\nocite{*}
	\bibliography{TTP}
	\vfill
	O histórico do desenvolvimento desse trabalho se encontra online em:\\ \url{https://github.com/Durfan/ufsj-aeds3-tp2}.
\end{flushleft}

\end{document}
