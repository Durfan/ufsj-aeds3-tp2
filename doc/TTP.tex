\documentclass[12pt,a4paper]{article}

\usepackage[left=3.00cm, right=2.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\usepackage{lmodern}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}

\usepackage{indentfirst}
\usepackage{setspace}
\onehalfspacing

\usepackage[numbers]{natbib}
\usepackage{url}
\bibliographystyle{plainnat}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsfonts}

\usepackage{booktabs}
\usepackage{float}

\usepackage{tikz}
\usepackage[portuguese, ruled]{algorithm2e}
\usepackage{copyrightbox}

\makeatletter
\newcommand{\algorithmfootnote}[2][\footnotesize]{%
	\let\old@algocf@finish\@algocf@finish% Store algorithm finish macro
	\def\@algocf@finish{\old@algocf@finish% Update finish macro to insert "footnote"
		\leavevmode\rlap{\begin{minipage}{\linewidth}
				#1#2
		\end{minipage}}%
	}%
}
\makeatother

\makeatletter
\renewcommand*\env@matrix[1][\arraystretch]{%
	\edef\arraystretch{#1}%
	\hskip -\arraycolsep
	\let\@ifnextchar\new@ifnextchar
	\array{*\c@MaxMatrixCols c}}
\makeatother

\author{Pablo Cecilio Oliveira\\
	Alexander Cristian}
\title{Algorítimos e Estrutura de Dados III\\
O Problema da Viagem do Torneio}
\date{}

\begin{document}
\maketitle

\section{Introdução}

Otimização é o processo de melhorar algo. Basicamente é a ferramenta de matemática que nós confiamos para obter respostas aos problemas. Em matemática e ciência da computação, um problema de otimização é o problema de encontrar a melhor solução de todas as soluções viáveis. A terminologia “melhor” solução implica que há mais de uma solução e as elas não são de igual valor. Esses problemas de otimização no domínio científico e da vida real encontram soluções em pesquisa algorítmica que mostra o uso de métodos clássicos, métodos heurísticos e baseados na natureza métodos para calcular a solução.

Na solução de problemas difíceis onde não há soluções exatas eficientes, abordagens heurísticas como Simulated Annealing, Busca Tabu, GRASP (Greedy Randomized Adaptive Search Procedure), VNS (Variable Neighborhood Search), VND (Variable Neighborhood Descent), o ILS (Iterated Local Search) e o Método de Reconexão por Caminhos (Path Relinking) se tornam alternativas populares.

Então neste trabalho nós apresentamos um algoritmo que faz uso de uma dessas abordagens, para resolver um problema de otimização conhecido como Traveling Tournament Problem.


\subsection{Especificação do problema}

O Problema da viagem do torneio (Traveling Tournament Problem) é um problema de agendamento de esportes que abstrai as questões importantes na criação horários, onde a viagem em equipe é uma questão importante. Ligas esportivas profissionais existem em todo o mundo. Essas ligas são muitas vezes de grande importância econômica devido às enormes receitas geradas pela venda de bilhetes e direitos de transmissão para os jogos. Portanto, o planejamento dessas ligas é de suma importância. Um aspecto importante é a geração de um calendário para os torneios que especifica a ordem em que as equipes jogam entre si durante a temporada e o local de cada jogo. 

Portanto consideramos um torneio de n times, onde n é um número par. Em um torneio simple round-robin (SRR), cada time joga com cada um dos demais exatamente uma vez, nas n - 1 rodadas pré-estabelecidas. O jogo entre os times i e j é representado pelo par não ordenado i, j. Há n=2 jogos em cada rodada. Cada time joga exatamente uma vez por rodada. Em um torneio double round-robin (DRR), cada time joga com cada um dos outros duas vezes, uma em casa e outra fora de casa. Um torneio mirrored double round-robin (MDRR) é um torneio SRR nas primeiras n – 1 rodadas, seguido das mesmas rodadas iniciais mas invertendo a sua localização. Uma viagem é uma sequência de jogos fora de casa. Enquanto uma estadia é uma sequência de jogos em casa. Assumimos que cada time tem um estádio para seu uso na sua cidade natal. As distâncias entre as cidades são conhecidas. Cada time parte de sua cidade no início do torneio e retorna à sua cidade no fim do torneio, se já não estiver lá. Sempre que duas rodadas de um time forem fora de casa, ele não retorna à sua cidade natal entre elas. 

O problema da viagem do torneio (Traveling Tournament Problem) é definido como a seguir. Dados n times e as distâncias entre as suas cidades de origem, o problema consiste em definir uma sequência DRR de tal forma que nenhum time joga mais de três jogos fora de casa, não há repetições (ou seja, dois jogos consecutivos entre os mesmos times em localidades diferentes), e a soma das distâncias percorridas pelos times é minimizada. O problema da viagem do torneio espelhada tem uma restrição adicional: os jogos da rodada k são os mesmos da rodada k + (n- 1), k = 1; . . . ; n - 1, com a localização invertida.

\subsection{Solução proposta}

Para a resolução deste problema utilizamos o método de GRASP (Greedy Randomized Adaptive Search Procedures) que é uma meta-heurística constituída por heurísticas construtivas e busca local. Consiste de múltiplas aplicações de busca local, cada uma iniciando de uma solução diferente. As soluções iniciais são geradas por algum tipo de construção randômica gulosa ou algum esquema de perturbação, esse método é constituído basicamente de duas fases: uma fase de construção e uma fase de busca local, cujo objetivo é convergir à solução encontrada na fase de construção para um ótimo local.

%A primeira fase é a fase de construção, no qual a solução viável é construída elemento a elemento. Cada elemento da solução é avaliado e, em seguida, é adicionado ordenadamente de acordo com um critério guloso, em uma lista, denominada de Lista de Candidatos (LC). Através de um fator $α ∈[0,1]$ é criado a Lista Restrita de Candidatos (LRC), cujos elementos são os melhores da LC e cujo tamanho é $| LRC |$ $=$ $α×$ $| LC |$ , onde $| LC |$ é o numero de elementos da lista de candidatos. Definido a LRC, seleciona-se, aleatoriamente, um candidato da LRC e, em seguida, atualiza-se ambas as listas LC e LRC. O método para quando LC $=$ Ø .

Na segunda fase ocorre o refinamento da solução gerada pela fase de construção, aplicando um método de busca local. Quanto melhor é a qualidade da solução gerada pela heurística de construção, maior é a velocidade de convergência desta solução para um ótimo local.


\section{Implementação}

Para a construção de uma solução inicial, utiliza-se o método de três fases proposto por Ribeiro e Urrutia (2004a)\cite{urrutia:heuristics}.

\subsection{Método de três fases para geração de uma solução inicial}

\subsubsection{Primeira fase: Método do Polígono}

A primeira fase da solução inicial consiste em uma fatoração que utiliza o Método do Polígono. Nesse método, sendo $n$ o número de times participantes do campeonato, forma-se um polígono com $n-1$ nós numerados e um $n$-ésimo time é atribuído a um nó fora desse polígono.

A cada rodada, os times localizados nos nós $k=2,3,...,n/2$ jogam contra os times localizados nos nós $n+1-k$, o $n$-ésimo time localizado fora do polígono joga contra o time localizado no primeiro nó do polígono. Para as $n-1$ rodadas seguintes, o polígono é movido em sentido horário para determinar os novos jogos. A Figura \ref{poligono}, demonstra a fatoração para as três primeiras rodadas de um campeonato com $6$ times.

\begin{figure}[H]
	\centering
	\caption{Método do Polígono para três primeiras rodadas com n = 6}
	\label{poligono}
	\vspace{.6cm}
	\begin{tikzpicture}
		\tikzstyle{every node}=[draw, shape=circle, inner sep=4pt];
		\tikzstyle{every path}=[draw, line width=0.4mm];
		\node (F) at (0,6) {$6$};
		\node (A) at (0,4) {$1$};
		\node (B) at (2,2.25) {$2$};
		\node (C) at (1.25,0) {$3$};
		\node (D) at (-1.25,0) {$4$};
		\node (E) at (-2,2.25) {$5$};
		\draw (A)--(B)--(C)--(D)--(E)--(A);
		\draw [<->] (0,5.5) -- (0,4.5);
		\draw [<->] (-1.5,2.25) -- (1.5,2.25);
		\draw [<->] (-0.8,0.2) -- (0.8,0.2);
	\end{tikzpicture}
	\hfil
	\begin{tikzpicture}
		\tikzstyle{every node}=[draw, shape=circle, inner sep=4pt];
		\tikzstyle{every path}=[draw, line width=0.4mm];
		\node (F) at (0,6) {$6$};
		\node (A) at (0,4) {$5$};
		\node (B) at (2,2.25) {$1$};
		\node (C) at (1.25,0) {$2$};
		\node (D) at (-1.25,0) {$3$};
		\node (E) at (-2,2.25) {$4$};
		\draw (A)--(B)--(C)--(D)--(E)--(A);
		\draw [<->] (0,5.5) -- (0,4.5);
		\draw [<->] (-1.5,2.25) -- (1.5,2.25);
		\draw [<->] (-0.8,0.2) -- (0.8,0.2);
		\draw [->] (1,4.25) to[out=10,in=-270] (2.25,3.25);
	\end{tikzpicture}
	\hfil
	\begin{tikzpicture}
		\tikzstyle{every node}=[draw, shape=circle, inner sep=4pt];
		\tikzstyle{every path}=[draw, line width=0.4mm];
		\node (F) at (0,6) {$6$};
		\node (A) at (0,4) {$4$};
		\node (B) at (2,2.25) {$5$};
		\node (C) at (1.25,0) {$1$};
		\node (D) at (-1.25,0) {$2$};
		\node (E) at (-2,2.25) {$3$};
		\draw (A)--(B)--(C)--(D)--(E)--(A);
		\draw [<->] (0,5.5) -- (0,4.5);
		\draw [<->] (-1.5,2.25) -- (1.5,2.25);
		\draw [<->] (-0.8,0.2) -- (0.8,0.2);
		\draw [->] (1,4.25) to[out=10,in=-270] (2.25,3.25);
	\end{tikzpicture}
	\vspace{.3cm}\\
	\footnotesize Fonte: \Citeauthor{marcio:jogos} \Citep{marcio:jogos}
\end{figure}

\begin{table}[H]
	\centering
	\caption{Solução obtida pelo Método do Polígono}
	\label{tab:poligono}
	\begin{tabular}{l*{10}{c}}
		\toprule
		& 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
		\midrule
		Time 1 & 6 & 4 & 2 & 5 & 3 & 6 & 4 & 2 & 5 & 3 \\
		Time 2 & 5 & 3 & 1 & 4 & 6 & 5 & 3 & 1 & 4 & 6 \\
		Time 3 & 4 & 2 & 5 & 6 & 1 & 4 & 2 & 5 & 6 & 1 \\
		Time 4 & 3 & 1 & 6 & 2 & 5 & 3 & 1 & 6 & 2 & 5 \\
		Time 5 & 2 & 6 & 3 & 1 & 4 & 2 & 6 & 3 & 1 & 4 \\
		Time 6 & 1 & 5 & 4 & 3 & 2 & 1 & 5 & 4 & 3 & 2 \\
		\bottomrule
		\footnotesize Fonte: autores
	\end{tabular}
\end{table}

A Tabela \ref{tab:poligono} mostra os resultados obtidos pelo Método do Polígono para $6$ times nas primeiras $n-1$ rodadas e espelhado para as $n-1$ rodadas seguintes no MDRR. O mesmo método pode ser aplicado aos 20 times requeridos nesse trabalho prático, para esse número de times ou qualquer outro número par de times, um polígono com $n-1$ vértices é utilizado.

\subsubsection{Segunda fase: Associando Times}

A segunda fase consiste na associação entre os times reais e os times abstratos. Para representar times abstratos usam-se as letras correspondentes aos números gerados pelo método do polígono, já os times reais são representados por números, correspondentes a ordem de seus índices.

Para essa fase, primeiro obtêm-se uma matriz quadrada de $n \times n$ oponentes consecutivos gerada partir da escala criada pelo Método do Polígono.

São considerados como ''oponentes consecutivos'' no caso em que um time $T_{k}$ possuir confrontos entre $T_{i} \times T_{k}$ e $T_{j} \times T_{k}$ em uma ou mais rodadas consecutivas, não importando a ordem dos jogos. Como exemplo, observa-se na Tabela \ref{tab:consecutivos} que os times B e E são oponentes consecutivos por 6 vezes de outros times.

\begin{table}[H]
	\centering
	\caption{Oponentes consecutivos}
	\label{tab:consecutivos}
	\begin{tabular}{l*{10}{c}}
		\toprule
		& 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
		\midrule
		Time 1 & F & D & \textbf{B} & \textbf{E} & C & F & D & \textbf{B} & \textbf{E} & C \\
		Time 2 & E & C & A & D & F & E & C & A & D & F \\
		Time 3 & D & \textbf{B} & \textbf{E} & F & A & D & \textbf{B} & \textbf{E} & F & A \\
		Time 4 & C & A & F & \textbf{B} & \textbf{E} & C & A & F & \textbf{B} & \textbf{E} \\
		Time 5 & B & F & C & A & D & B & F & C & A & D \\
		Time 6 & A & E & D & C & B & A & E & D & C & B \\
		\bottomrule
		\footnotesize Fonte: autores
	\end{tabular}
\end{table}

A Figura \ref{matriz:consecutivos} demonstra a matriz quadrada de oponentes consecutivos dos jogos entre os times abstratos. Nessa matriz podemos observar que além de B e E serem oponentes consecutivos por 6 vezes, outros times também são consecutivos por uma ou mais vezes, como exemplo, C e A também são consecutivos por 6 vezes.

\begin{figure}[H]
	\centering
	\caption{Matriz de oponentes consecutivos para $n=6$}
	\label{matriz:consecutivos}
	\vspace{-0.7cm}
	\[ \begin{bmatrix}[0.8]
	0 & 1 & 6 & 5 & 2 & 4 \\
	1 & 0 & 2 & 5 & 6 & 4 \\
	6 & 2 & 0 & 2 & 5 & 3 \\
	5 & 5 & 2 & 0 & 2 & 4 \\
	2 & 6 & 5 & 2 & 0 & 3 \\
	4 & 4 & 3 & 4 & 3 & 0
	\end{bmatrix} \]
	\footnotesize Fonte: autores
\end{figure}

A associação, então, ocorre entre os pares de times reais que possuem a menor distância entre suas sedes com os pares de oponentes consecutivos de maior número de confrontos. Essa heurística é descrita a seguir.

Inicialmente, pares de times abstratos são ordenados em ordem decrescente conforme o número de oponentes consecutivos (Tabela \ref{tab:abstratos}). Times reais são ordenados em ordem crescente de distância em relação às sedes de seus oponentes (Tabela \ref{tab:reais}), e são associados aos times abstratos nesta ordem. Dessa forma, os times abstratos com maior número de oponentes consecutivos serão preferencialmente associados aos times reais com as distâncias entre sedes menores.

\begin{table}[H]
	\centering
	\caption{Pares ordenados de times reais.}
	\label{tab:reais}
	\vspace{0.2cm}
	\begin{tabular}{cclr}
		\toprule
		 1 & (2,6) & (Atlético Mineiro, Cruzeiro) & 0 Km \\
		 2 & (1,6) & (América Mineiro, Cruzeiro) & 0 Km \\
		 3 & (1,2) & (América Mineiro, Atlético Mineiro) & 0 Km \\
		 4 & (3,5) & (Atlético Paranaense, Corinthians) & 415 Km \\
		 5 & (2,4) & (Atlético Mineiro, Botafogo) & 440 Km \\
		 6 & (1,4) & (América Mineiro, Botafogo) & 440 Km \\
		 7 & (4,6) & (Botafogo, Cruzeiro) & 441 Km \\
		 8 & (4,5) & (Botafogo, Corinthians) & 444 Km \\
		 9 & (1,5) & (América Mineiro, Corinthians) & 585 Km \\
		10 & (2,5) & (Atlético Mineiro, Corinthians) & 585 Km \\
		11 & (5,6) & (Corinthians, Cruzeiro) & 587 Km \\
		12 & (3,4) & (Atlético Paranaense, Botafogo) & 849 Km \\
		13 & (1,3) & (América Mineiro, Atlético Paranaense) & 1000 Km \\
		14 & (2,3) & (Atlético Mineiro, Atlético Paranaense) & 1000 Km \\
		15 & (3,6) & (Atlético Paranaense, Cruzeiro) & 1001 Km \\
		\bottomrule
	\end{tabular}
	\vspace{0.2cm}\\
	\footnotesize Fonte: autores
\end{table}

\begin{table}[H]
	\centering
	\caption{Pares ordenados de times abstratos.}
	\label{tab:abstratos}
	\vspace{0.2cm}
	\begin{tabular}{rcc c rcc c rcc}
		\toprule
		 1 & (E,B) & 6 && 11 & (D,F) & 4 && 21 & (D,E) & 2 \\
		 2 & (C,A) & 6 && 12 & (F,A) & 4 && 22 & (C,D) & 2 \\
		 3 & (B,E) & 6 && 13 & (F,D) & 4 && 23 & (C,B) & 2 \\
		 4 & (A,C) & 6 && 14 & (B,F) & 4 && 24 & (B,C) & 2 \\
		 5 & (E,C) & 5 && 15 & (A,F) & 4 && 25 & (E,D) & 2 \\
		 6 & (D,B) & 5 && 16 & (F,B) & 4 && 26 & (A,E) & 2 \\
		 7 & (D,A) & 5 && 17 & (E,F) & 3 && 27 & (E,A) & 2 \\
		 8 & (C,E) & 5 && 18 & (F,C) & 3 && 28 & (D,C) & 2 \\
		 9 & (B,D) & 5 && 19 & (F,E) & 3 && 29 & (B,A) & 1 \\
		10 & (A,D) & 5 && 20 & (C,F) & 3 && 30 & (A,B) & 1 \\
		\bottomrule
	\end{tabular}
	\vspace{0.2cm}\\
	\footnotesize Fonte: autores
\end{table}

O pseudo-código para a heurística dessa associação é mostrado no Algorítimo \ref{alg:associa}.

\vspace{0.5cm}
\begin{algorithm}[H]
	\caption{Associa times reais à times abstratos}
	\algorithmfootnote{Fonte: \Citeauthor{marcio:jogos} \Citep{marcio:jogos}}
	\label{alg:associa}
	\Repita{todos os times reais sejam associados aos times abstratos} {
		Seja $T_{1}$ o próximo time real a ser associado a um time abstrato\\
		e seja $T_{2}$ o time, cuja cidade é mais próxima à cidade de $T_{1}$.\\
		\eSe{$T_{2}$ já foi associado} {
			Encontre o primeiro par $(a,b)$ de times abstratos, tal que $a$ esteja\\
			associado ao time $T_{2}$ e $b$ ainda não esteja associado a nenhum time real.\\
			$b \leftarrow T_{1}$ }
		{ Encontre o primeiro par $(a,b)$ de times abstratos, tal\\
			que nenhum deles esteja associado a um time real.\\
			$a \leftarrow T_{1}$ } }
\end{algorithm}
\vspace{0.5cm}

Essa associação tem como objetivo minimizar o deslocamento de um time $T_{k}$, baseando-se na ideia de que se existirem confrontos $T_{i} \times T_{k}$ e $T_{j} \times T_{k}$ consecutivos, a distância percorrida por $T_{k}$ seria menor caso suas sedes forem próximas.

\subsubsection{Terceira fase: Mando de Campo}

Na terceira e última fase para gerar uma solução inicial, são estabelecidos os mandos de campo. Considera-se para isso a restrição de três jogos consecutivos dentro ou fora de casa, assim sendo, para gerar uma escala viável deve-se alternar o máximo possível o mando de campo.

Os mandos de campo da primeira rodada são determinados aleatoriamente, e nas rodadas seguintes até a última do primeiro turno ($n-1$), uma heurística é utilizada para determinar o mando de um jogo entre os times $T_{1}$ e $T_{2}$.

Para que a heurística possa ser usada, é preciso definir $N_{i}$ como a quantidade total de jogos consecutivos dentro ou fora de casa que um time $T_{i}$ jogou em rodadas anteriores, e a partir desse valor, o algorítimo \ref{alg:mando} é aplicado.

\begin{algorithm}[H]
	\caption{Determina o mando de campo dos jogos}
	\algorithmfootnote{Fonte: \Citeauthor{marcio:jogos} \Citep{marcio:jogos}}
	\label{alg:mando}
	Determine, de forma aleatória, o mando de campo dos jogos da primeira rodada.\\
	\ParaCada{rodada $k = 2,3,...,(n-1)$ do primeiro turno}{
		
		\Se{$N_{2} > N_{1}$}{
			\lSe{Se $T_{2}$ jogou seu último jogo em casa}{a realização do jogo será na casa do time $T_{1}$}
			\lSe{Se $T_{2}$ jogou seu último jogo fora de casa}{a realização do jogo será na casa do time $T_{2}$}	
		}
	
		\Se{$N_{2} < N_{1}$}{
			\lSe{Se $T_{1}$ jogou seu último jogo em casa}{a realização do jogo será na casa do time $T_{2}$}
			\lSe{Se $T_{1}$ jogou seu último jogo fora de casa}{a realização do jogo será na casa do time $T_{1}$}	
		}
	
		\Se{$N_{2} = N_{1}$}{
			\lSe{$T_{1}$ jogou seu último jogo em casa e o time $T_{2}$ jogou seu último jogo fora de casa}{a realização do jogo será na casa do time $T_{2}$}
			\lSe{$T_{1}$ jogou seu último jogo fora de casa e o time $T_{2}$ jogou seu último jogo em casa}{a realização do jogo será na casa do time $T_{1}$}
			\lSenao{o mando de campo é determinado aleatoriamente}
		}
	}
	Determinar os jogos do segundo turno espelhados ao primeiro turno.\\
	Caso a escala ainda permanecer inviável, reinicie o algoritmo.
\end{algorithm}

\section{Análise de complexidade}

Para as Funções utilizadas pelo programa as quais um número fixo de instruções, sejam eles $k$, são executas independente de $n$, essas classificam-se como $O(1)$ ou de complexidade constante. Dentre as listadas nas seções seguintes, se encontram:

\begin{itemize}
	\setlength\itemsep{1pt}
	\item Funções que retornam uma condição booleana; 
	\item Inicialização da Lista Simplesmente Encadeada;
	\item Inserção ou remoção de um nó a partir do nó ''cabeça'' de uma Lista Simplesmente Encadeada;
	\item Funções de retorno de impressão para mensagens de erro, ou para o retorno de impressão do tempo decorrido até determinado ponto relativo ao código;
	\item A Função que realiza a copia de um trecho de memória, ou a que retorna um conteúdo endereçado diretamente para uma área de memoria;
	\item A Função que gera um números randômicos através do seed fornecido pelo sistema.
\end{itemize}

Para as Funções analisadas como sendo de complexidade linear, ou $O(n)$, tais que $n$ mais um número fixo de instruções são menores do que $cn$ ($f(n) = (n+1) \Rightarrow (n+1) \leqslant cn$). Essas compõe a maioria do programa e são listadas de forma geral a seguir:

\begin{itemize}
	\setlength\itemsep{1pt}
	\item A Função que retorna um o numero de linhas de um arquivo;
	\item Funções que carregam os dados dos arquivos para estruturas de dados;
	\item Funções que carregam os dados dos arquivos para estruturas de dados;
	\item Funções de uso geral da Lista Simplesmente Encadeada:
	\begin{itemize}
		\setlength\itemsep{1pt}
		\item Funções que retorna um nó que contem um menor valor de um dado, ou a que retorna um nó que contem o maior valor de um dado;
		\item Função que retorna a posição de um nó na lista;
		\item Funções que carregam os dados dos arquivos para estruturas de dados;
		\item Funções que removem ou inserem um nó da Lista conforme sua posição;
		\item Função que troca as posições de dois nós;
		\item Função que remove nós com dados duplicados;
		\item Funções que ordenam a lista em ordem crescente ou decrescente;
		\item Função que retorna a impressão da Lista;
		\item Função que libera os dados da Lista da memoria
	\end{itemize}
	\item Funções de uso geral da Lista Simplesmente Encadeada:
\end{itemize}

\subsection{Funções de arquivos para os dados}

\begin{table}[H]
	\renewcommand{\arraystretch}{1}
	\centering
	\caption{Funções de arquivos para os dados.}
	\label{tab:arquivos}
	\begin{tabular}{p{2.7cm} p{9.5cm} c}
		\toprule 
		Função & Finalidade & Complexidade \\ 
		\midrule
		$getlines()$ & Retorna o numero de linhas validas de um arquivo. & $O(n)$ \\
		$getCLUB()$ & Carrega os clubes a partir do arquivo de clubes, salva os dados em array struct. & $O(n)$ \\
		$getCITY()$ & Carrega as cidades a partir do arquivo de cidades, salva os dados em um array struct. & $O(n)$ \\
		$getDIST()$ & Carrega as distancias a partir do arquivo de distancias, salva os dados em uma matriz alocada. & $O(n)$ \\
		$errFile()$ & Retorna a msg de erro caso o arquivo não for encontrado. & $O(1)$ \\
		\bottomrule
		\footnotesize Fonte: autores
	\end{tabular}
\end{table}

\subsection{Funções da Lista Encadeada Simples}

\begin{table}[H]
	\renewcommand{\arraystretch}{1}
	\centering
	\caption{Funções da Lista Encadeada Simples.}
	\label{tab:linkedlist}
	\begin{tabular}{p{2.7cm} p{9.5cm} c}
		\toprule 
		Função & Finalidade & Complexidade \\ 
		\midrule
		$create()$ & Inicializa uma Lista Encadeada Simples & $O(1)$ \\
		$atP()$ & Dada a posição, retorna um nó da Lista. & $O(n)$ \\
		$LLmin()$ & Retorna um nó com o menor valor de um dado. & $O(n)$ \\
		$LLmax()$ & Retorna um nó com o maior valor de um dado. & $O(n)$ \\
		$LLidx()$ & Retorna a posição de um nó. & $O(n)$ \\
		$LLpsh()$ & Insere os dados a partir da posição cabeça. & $O(1)$ \\
		$LLpop()$ & Remove os dados a partir da posição cabeça. & $O(1)$ \\
		$LLdel()$ & Remove um nó, dado sua posição na Lista. & $O(n)$ \\
		$LLins()$ & Insere um nó, dado sua posição na Lista. & $O(n)$ \\
		$LLchg()$ & Troca a posição de dois nós. & $O(n)$ \\
		$LLdup()$ & Remove os nós com dados duplicados. & $O(n)$ \\
		$LLinc()$ & Ordena a Lista em ordem crescente. & $O(n)$ \\
		$LLdec()$ & Ordena a Lista em ordem decrescente. & $O(n)$ \\
		$LLprt()$ & Retorna a impressão da Lista. & $O(n)$ \\
		$LLclr()$ & Libera os dados da Lista da memoria. & $O(n)$ \\
		$isEmpty()$ & Retorna se uma Lista está ou não vazia. & $O(1)$ \\
		\bottomrule
		\footnotesize Fonte: autores
	\end{tabular}
\end{table}

\subsection{Funções de Retorno de Impressão}

\begin{table}[H]
	\renewcommand{\arraystretch}{1}
	\centering
	\caption{Funções da Solução inicial.}
	\label{tab:print}
	\begin{tabular}{p{2.7cm} p{9.5cm} c}
		\toprule 
		Função & Finalidade & Complexidade \\ 
		\midrule
		$printTabela()$ & Retorna a impressão formatada da escala. & $O(n^2)$ \\
		$printEscala()$ & Retorna a impressão não formatada da escala.. & $O(n^2)$ \\
		$printTravel()$ & Retorna a impressão das distancias percorrida por cada um dos times. & $O(n)$ \\
		$printMatrix()$ & Retorna a impressão de uma matriz $n \times n$. & $O(n^2)$ \\
		$printCLUB()$ & Retorna a impressão não formatada do array struct de clubes. & $O(n^2)$ \\
		$printCITY()$ & Retorna a impressão não formatada do array struct de cidades.. & $O(n^2)$ \\
		\bottomrule
		\footnotesize Fonte: autores
	\end{tabular}
\end{table}

\subsection{Funções da Solução inicial}

\begin{table}[H]
	\renewcommand{\arraystretch}{1}
	\centering
	\caption{Funções da Solução inicial.}
	\label{tab:s0}
	\begin{tabular}{p{2.7cm} p{9.5cm} c}
		\toprule 
		Função & Finalidade & Complexidade \\ 
		\midrule
		$initPolygon()$ & One-factorization para gerar uma tabela inicial valida. & $O(n^2)$ \\
		$associaClub()$ & Associa os times reais aos times abstratos conforme o pseudo-código descrito no Algorítimo \ref{alg:associa}. & $O(n^2)$ \\
		$changeClube()$ & Altera o índice dos clubes conforme a associação realizada em $associaClub()$. & $O(n)$ \\
		$buildCalvin()$ & Cria os pares de times reais para $associaClub()$. & $O(n)$ \\
		$buildHarold()$ & Cria os pares de times abstratos para $associaClub()$. & $O(n)$ \\
		$buildLinked()$ & Cria uma lista encadeada de times associados para $associaClub()$. & $O(n)$ \\
		$islinked()$ & Verifica se um time real já esta associado. & $O(1)$ \\
		$associar()$ & Associa times reais/abstratos na lista criada por $buildlinked()$. & $O(n)$ \\
		$areClubs()$ & Verifica se todos os times já foram associados. & $O(n)$ \\
		$findAT1()$ & Função booleana de retorno para $associaClub()$. & $O(1)$ \\
		$findBT1()$ & Função booleana de retorno para $associaClub()$. & $O(1)$ \\
		\bottomrule
		\footnotesize Fonte: autores
	\end{tabular}
\end{table}

\subsection{Funções de uso comum ao programa}

\begin{table}[H]
	\renewcommand{\arraystretch}{1}
	\centering
	\caption{Funções de uso comum ao programa.}
	\label{tab:comum}
	\begin{tabular}{p{2.7cm} p{9.5cm} c}
		\toprule 
		Função & Finalidade & Complexidade \\ 
		\midrule
		$allocTable()$ & Aloca uma matriz de ponteiros. & $O(n)$ \\
		$freeMemory()$ & Libera a memoria alocada por $allocTable()$. & $O(n)$ \\
		$copyTable()$ & Copia dados entre matrizes. & $O(n^2)$ \\
		$shiftArray()$ & Movimenta os dados em um array (shift). & $O(1)$ \\
		$viagem()$ & Retorna a distancia entre as sedes dos times. & $O(1)$ \\
		$custos()$ & Calcula e retorna os custos totais de uma escala de jogos gerada, assim como o custo de deslocamento individual dos times. & $O(n^2)$ \\
		$timeresult()$ & Retorna o tempo de execução até determinado ponto. & $O(1)$ \\
		$wait()$ & Função de espera (pausa o tempo de execução por $n$ segundos). & $O(n)$ \\
		$ask()$ & Espera por um input fornecido pelo usuário. & $O(n)$ \\
		\bottomrule
		\footnotesize Fonte: autores
	\end{tabular}
\end{table}

\section{Análise de resultados}

\begin{table}[H]
	\centering
	\caption{Análise dos resultados.}
	\label{tab:resultados}
	\vspace{0.2cm}
	\begin{tabular}{ccccccr}
		\toprule 
		$S_{0}$ & $S_{k}$ & $k$ & Tentativas & Tempo & Diferença \% & Ganho \\ 
		\midrule
		837635 & 784889 &  3 & 19698 & 1s 903ms &  6.30\% &  52746 \\
		848148 & 790269 & 10 & 18519 & 1s 795ms &  6.82\% &  57879 \\
		814842 & 772594 &  9 & 19458 & 1s 892ms &  5.18\% &  42248 \\
		864708 & 782358 &  5 & 18773 & 1s 823ms &  9.52\% &  82350 \\
		858557 & 780693 &  8 & 19692 & 1s 910ms &  9.07\% &  77864 \\
		858637 & 755076 &  9 & 19651 & 1s 912ms & 12.06\% & 103561 \\
		840565 & 781085 &  4 & 20540 & 1s 984ms &  7.08\% &  59480 \\
		825463 & 781733 &  6 & 18880 & 1s 830ms &  5.30\% &  43730 \\
		848581 & 772612 &  9 & 19195 & 1s 862ms &  8.95\% &  75969 \\
		844549 & 770172 &  8 & 18408 & 1s 791ms &  8.81\% &  74377 \\
		865979 & 779945 &  6 & 20467 & 1s 985ms &  9.93\% &  86034 \\
		857004 & 767938 &  5 & 19898 & 1s 928ms & 10.39\% &  89066 \\
		795849 & 774157 &  3 & 19754 & 1s 914ms &  2.73\% &  21692 \\
		862298 & 769219 &  8 & 18952 & 1s 846ms & 10.79\% &  93079 \\
		842242 & 777349 &  4 & 19309 & 1s 868ms &  7.70\% &  64893 \\
		\midrule
		844337 & 776005 &    &       &          &  8.09\% &  68332 \\
		\bottomrule
		\footnotesize Fonte: autores
	\end{tabular}
\end{table}

     


       


\section{Considerações finais}

Durante o desenvolvimento vários métodos foram testados com o objetivo de encontrar a maneira mais eficiente de solucionar o problema da viagem do torneio.
//comentários sobre as dificuldades no desenvolvimento do código

\pagebreak

\begin{flushleft}
	\nocite{*}
	\bibliography{TTP}
	\vfill
	O histórico do desenvolvimento desse trabalho se encontra online em:\\ \url{https://github.com/Durfan/ufsj-aeds3-tp2}.
\end{flushleft}

\end{document}
